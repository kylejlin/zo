enum Nat
    zero
    succ(pred: Nat)
end

enum* Eq(T: Type, left: T) ^(right: T)
    refl ^(left)
end

def add(dec a: Nat, b: Nat) -> Nat
    match a
    case zero:
        b
    case succ(a_pred):
        succ(add(a_pred, b))
    end
    
enum List(T: Type)
    nil
    cons(head: T, tail: List)
end

enum Bool
    false
    true
end

def filter(T: Type, dec l: List(T), p: For(_: T) -> Bool) -> List(T)
    match l
    case nil:
        nil
    case cons(head, tail):
        match p(head)
        case true:
            cons(head, filter(tail, p))
        case false:
            filter(tail, p)
        end
    end

n1 = succ(zero)
n2 = succ(n1)
n3 = succ(n2)

list123 = cons(Nat)(n1,
    cons(Nat)(n2,
        cons(Nat)(n3, nil(Nat))
    )
)

def sum(dec l: List(Nat)) -> Nat
    match l
    case nil:
        zero
    case cons(head, tail):
        add(head, sum(tail))
    end

n8 =
    n6 = sum(list123)

    enum CoinSide
        heads
        tails
    end

    garbage = zero

    match heads
    case heads:
        add(n2, n6)
    case tails:
        garbage
    end
