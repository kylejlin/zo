ind Nat
    case zero
    case succ(pred: Nat)
    return Set0

ind Eq0[_: Nat]
    case refl: [zero]
    return Prop0

let one = succ(zero)

ind(T: Set0, left: T) Eq[_: T]
    case refl: [left]
    return Set0

// Using non-def ind:
let Eq2 = afun(T: Set0, left: T): Set0
    aind Eq2[_: T]
        case refl: [left]
        return Set0

let refl2 = afun(T: Set0, left: T): Eq2(T, left)(left)
    vcon0 Eq2[_: T]
        case refl: [left]
        return Set0

// Flat-equality
fun Fleq(T: Set0, left: T, right: T): Set0
    Eq(T, left)(right)

ind(T: Set0) List
    case nil
    case cons(car: T, cdr: List)
    return Set0

fun add(-a: Nat, b: Nat): Nat
    match a
    case zero:
        b
    case succ(pred):
        succ(add(pred, b))
    return Nat

// Using non-def fun:
let add2 = afun add2(-a: Nat, b: Nat): Nat
    match a
    case zero:
        b
    case succ(pred):
        succ(add2(pred, b))
    return Nat

let two = add(one, one)

ind Bool
    case true
    case false
    return Set0

fun filter(T: Set0, -list: List(T), pred: For(_: T) -> Bool): List(T)
    match list
    case nil:
        nil(T)
    case cons(car, cdr):
        match pred(car)
        case true:
            cons(T)(car, filter(cdr, pred))
        case false:
            filter(cdr, pred)
        return List(T)
    return List(T)

fun eq_commutative(T: Set0, a: T, b: T, eq: Fleq(T, a, b)): Fleq(T, b, a)
    match eq
    case refl:
        refl(T, a)
    use [c] return Fleq(T, c, a)
    