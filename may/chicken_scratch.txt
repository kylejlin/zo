ind Nat: Set0
    case zero
    case succ(pred: Nat)

ind Eq0(_: Nat): Prop0
    case refl: Eq0(zero)

let one = succ(zero)

ind(T: Set0, left: T) Eq(_: T): Set0
    case refl: Eq(left)

// Using non-def ind:
let Eq2 = afun(T: Set0, left: T): Set0
    aind Eq2(_: T): Set0
        case refl: Eq2(left)

let refl2 = afun(T: Set0, left: T): Eq2(T, left)(left)
    vcon0(Eq2(T, left))

// Flat-equality
fun Fleq(T: Set0, left: T, right: T): Set0
    Eq(T, left)(right)

ind(T: Set0) List: Set0
    case nil
    case cons(car: T, cdr: List)

fun add(-a: Nat, b: Nat): Nat
    match a return Nat
    case zero: b
    case succ(pred): succ(add(pred, b))

// Using non-def fun:
let add2 = afun add2(-a: Nat, b: Nat): Nat
    match a return Nat
    case zero: b
    case succ(pred): succ(add2(pred, b))

let two = add(one, one)

ind Bool: Set0
    case true
    case false

fun filter(T: Set0, -list: List(T), pred: For(_: T) -> Bool): List(T)
    match list return List(T)
    case nil: nil(T)
    case cons(car, cdr):
        match pred(car) return List(T)
        case true: cons(T)(car, filter(cdr, pred))
        case false: filter(cdr, pred)

fun eq_commutative(T: Set0, a: T, b: T, eq: Fleq(T, a, b)): Fleq(T, b, a)
    match eq as _: _(c) return Fleq(T, c, a)
    case refl: refl(T, a)